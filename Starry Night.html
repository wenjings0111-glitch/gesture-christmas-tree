<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Starry Night Gesture Control - Pixel Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #d4af37; border-radius: 10px;
            overflow: hidden; transform: scaleX(-1); z-index: 100;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui {
            position: absolute; top: 40px; left: 40px; color: #d4af37;
            pointer-events: none; z-index: 100;
        }
        .label { font-size: 10px; letter-spacing: 4px; opacity: 0.6; text-transform: uppercase; }
        h1 { margin: 10px 0; font-weight: 200; font-size: 28px; letter-spacing: 2px; }
        #status { font-style: italic; color: #fff; text-shadow: 0 0 10px #d4af37; }

        #control-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 12px;
            padding: 15px;
            z-index: 1000;
            display: flex;
            flex-direction: column; gap: 12px; color: #d4af37;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
        .panel-item { display: flex; align-items: center; gap: 10px; font-size: 14px; }
        input[type="range"] { accent-color: #d4af37; cursor: pointer; }
        .panel-btns { display: flex; gap: 8px; }
        button {
            background: rgba(212, 175, 55, 0.2); border: 1px solid #d4af37; color: #d4af37;
            padding: 6px 12px; border-radius: 5px; cursor: pointer; transition: all 0.3s; font-size: 12px;
        }
        button:hover { background: rgba(212, 175, 55, 0.4); }
    </style>
</head>
<body>

    <div id="control-panel">
        <div class="panel-item">
            <label>ç²’å­é€Ÿåº¦</label>
            <input type="range" id="speed-slider" min="0" max="0.02" step="0.001" value="0.002">
        </div>
        <div class="panel-btns">
            <button onclick="toggleFullscreen()">å…¨å±å±•ç¤º</button>
            <button onclick="togglePreview()">ğŸ“· é¢„è§ˆæ˜¾ç¤º/éšè—</button>
        </div>
    </div>

    <div id="ui">
        <div class="label">Interactive Art Experience</div>
        <h1>STARRY NIGHT: PIXEL PARTICLES</h1>
        <div id="status">æ­£åœ¨åŠ è½½ã€Šæ˜Ÿå¤œã€‹åƒç´ æ•°æ®...</div>
    </div>

    <div id="video-container"><video id="input_video"></video></div>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry, treeStar;
        const PARTICLE_COUNT = 15000;
        let currentState = 'painting'; 
        let rotationSpeed = 0.002;
        let isPreviewVisible = true;
        let posPainting, posGather, posScatter, posSphere;
        let baseColors, goldColors, silverColors;

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            await loadPixelData("https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/600px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg");
            
            // --- è°ƒæ•´ï¼šåœ¨ç²’å­ç³»ç»Ÿåˆ›å»ºååˆ›å»ºæ˜Ÿæ˜Ÿï¼Œå¹¶å°†å…¶æ·»åŠ ä¸ºå­å¯¹è±¡ ---
            createTreeStar();

            initHands();
            
            document.getElementById('speed-slider').oninput = (e) => { rotationSpeed = parseFloat(e.target.value); };
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function createTreeStar() {
            const pts = [];
            const numPoints = 5;
            for (let i = 0; i < numPoints * 2; i++) {
                const l = i % 2 === 1 ? 10 : 25;
                const a = (i / numPoints) * Math.PI;
                pts.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));
            }
            const shape = new THREE.Shape(pts);
            const extrudeSettings = { depth: 8, bevelEnabled: true, bevelThickness: 2, bevelSize: 2 };
            const starGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const starMat = new THREE.MeshPhongMaterial({ 
                color: 0xffd700, emissive: 0xaa8800, specular: 0xffffff, shininess: 100 
            });
            treeStar = new THREE.Mesh(starGeo, starMat);
            
            const starLight = new THREE.PointLight(0xffd700, 1, 100);
            treeStar.add(starLight);
            
            // --- ä¿®æ”¹ï¼šæ˜Ÿæ˜Ÿä½ç½®å¾®è°ƒï¼Œå¹¶å°†å…¶é»åœ¨ç²’å­ç³»ç»Ÿä¸Š ---
            treeStar.position.set(0, 155, 0); 
            treeStar.visible = false; 
            treeStar.scale.set(0.001, 0.001, 0.001);
            
            // é»åœ¨ä¸€èµ·çš„å…³é”®ï¼šå°†æ˜Ÿæ˜Ÿä½œä¸ºç²’å­çš„å­å¯¹è±¡
            particles.add(treeStar); 
            
            scene.add(new THREE.AmbientLight(0x404040));
            // æ·»åŠ ä¸»å…‰æºç¡®ä¿3Dæ„Ÿ
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(0, 0, 500);
            scene.add(mainLight);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        function togglePreview() {
            isPreviewVisible = !isPreviewVisible;
            const container = document.getElementById('video-container');
            container.style.opacity = isPreviewVisible ? "1" : "0";
            container.style.pointerEvents = isPreviewVisible ? "auto" : "none";
        }

        async function loadPixelData(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200; canvas.height = 150; 
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    posPainting = new Float32Array(PARTICLE_COUNT * 3);
                    posGather = new Float32Array(PARTICLE_COUNT * 3);
                    posScatter = new Float32Array(PARTICLE_COUNT * 3);
                    posSphere = new Float32Array(PARTICLE_COUNT * 3);
                    baseColors = new Float32Array(PARTICLE_COUNT * 3);
                    goldColors = new Float32Array(PARTICLE_COUNT * 3);
                    silverColors = new Float32Array(PARTICLE_COUNT * 3);

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        const x = Math.floor(Math.random() * canvas.width);
                        const y = Math.floor(Math.random() * canvas.height);
                        const pixelIndex = (y * canvas.width + x) * 4;

                        posPainting[i3] = (x - canvas.width / 2) * 2.5;
                        posPainting[i3 + 1] = -(y - canvas.height / 2) * 2.5;
                        posPainting[i3 + 2] = 0;

                        const h = Math.random() * 300;
                        const rTree = (300 - h) * 0.3;
                        const angleTree = Math.random() * Math.PI * 2;
                        posGather[i3] = Math.cos(angleTree) * rTree;
                        posGather[i3 + 1] = h - 150;
                        posGather[i3 + 2] = Math.sin(angleTree) * rTree;

                        const radius = 150;
                        const u = Math.random(), v = Math.random();
                        const thetaSphere = 2 * Math.PI * u, phiSphere = Math.acos(2 * v - 1);
                        posSphere[i3] = radius * Math.sin(phiSphere) * Math.cos(thetaSphere);
                        posSphere[i3+1] = radius * Math.sin(phiSphere) * Math.sin(thetaSphere);
                        posSphere[i3+2] = radius * Math.cos(phiSphere);

                        posScatter[i3] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 1] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 2] = (Math.random() - 0.5) * 1000;

                        const r_col = imgData[pixelIndex] / 255, g_col = imgData[pixelIndex + 1] / 255, b_col = imgData[pixelIndex + 2] / 255;
                        baseColors[i3] = r_col; baseColors[i3+1] = g_col; baseColors[i3+2] = b_col;
                        goldColors[i3] = r_col * 0.8 + 0.2; goldColors[i3 + 1] = g_col * 0.7 + 0.15; goldColors[i3 + 2] = b_col * 0.5;
                        silverColors[i3] = r_col * 0.4 + 0.5; silverColors[i3 + 1] = g_col * 0.4 + 0.5; silverColors[i3 + 2] = b_col * 0.4 + 0.6;
                    }
                    createParticleSystem();
                    document.getElementById('status').innerText = "æ˜Ÿå¤œå°±ç»ªã€‚æ¡æ‹³å¬å”¤é‡‘è‰²åœ£è¯æ ‘ï¼";
                    resolve();
                };
            });
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posPainting), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(baseColors), 3));
            particles = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2.2, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
            scene.add(particles);
        }

        function transformTo(type) {
            let finalType = type;
            if (type === 'gather') {
                if (currentState === 'gather' || currentState === 'sphere') return;
                finalType = Math.random() > 0.5 ? 'gather' : 'sphere';
            } else if (currentState === type) return;

            currentState = finalType;
            
            // --- ä¿®æ”¹ï¼šæ˜Ÿæ˜Ÿéšæ ‘ä¸€èµ·å¹³æ»‘ç¼©æ”¾ ---
            if (finalType === 'gather') {
                treeStar.visible = true;
                gsap.to(treeStar.scale, { x: 1, y: 1, z: 1, duration: 1.2, ease: "back.out(1.7)" });
            } else {
                gsap.to(treeStar.scale, { x: 0.001, y: 0.001, z: 0.001, duration: 0.5, onComplete: () => treeStar.visible = false });
            }

            let targetPos, targetColor, statusText;
            if (finalType === 'gather') { targetPos = posGather; targetColor = goldColors; statusText = "æ¨¡å¼: é‡‘è‰²åœ£è¯æ ‘"; }
            else if (finalType === 'sphere') { targetPos = posSphere; targetColor = silverColors; statusText = "æ¨¡å¼: é“¶è‰²è¡Œçƒ"; }
            else if (finalType === 'scatter') { targetPos = posScatter; targetColor = baseColors; statusText = "æ¨¡å¼: æ•£å¼€æ€"; }
            else { targetPos = posPainting; targetColor = baseColors; statusText = "æ¨¡å¼: åç”»å¤åŸ"; }

            document.getElementById('status').innerText = statusText;
            const posAttr = geometry.attributes.position, colAttr = geometry.attributes.color;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                gsap.to(posAttr.array, { [i3]: targetPos[i3], [i3+1]: targetPos[i3+1], [i3+2]: targetPos[i3+2], duration: 1.5, ease: "power2.inOut", delay: Math.random() * 0.2, onUpdate: () => posAttr.needsUpdate = true });
                gsap.to(colAttr.array, { [i3]: targetColor[i3], [i3+1]: targetColor[i3+1], [i3+2]: targetColor[i3+2], duration: 1.5, onUpdate: () => colAttr.needsUpdate = true });
            }
        }

        function initHands() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    transformTo('painting');
                    return;
                }
                const landmarks = results.multiHandLandmarks[0];
                const fingerTips = [8, 12, 16, 20], wrist = landmarks[0];
                let totalDist = 0;
                fingerTips.forEach(idx => { totalDist += Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y); });

                if (totalDist < 0.6) transformTo('gather');
                else transformTo('scatter');

                const midX = landmarks[9].x - 0.5, midY = landmarks[9].y - 0.5;
                gsap.to(camera.position, { x: midX * 800, y: -midY * 800, duration: 0.8 });
                camera.lookAt(0, 0, 0);
            });

            new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 640, height: 480 }).start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                // --- ä¿®æ”¹ï¼šåœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹ï¼Œä¿æŒæ­£é¢æ˜¾ç¤º ---
                if (currentState === 'gather') {
                    // è®©ç²’å­ç³»ç»Ÿç¼“æ…¢è½¬åŠ¨å¢å¼ºç«‹ä½“æ„Ÿï¼Œä½†é€šè¿‡æŠµæ¶ˆè®©æ˜Ÿæ˜Ÿæ­£é¢æœå‰
                    particles.rotation.y += rotationSpeed * 0.5;
                    treeStar.rotation.y = -particles.rotation.y; // å…³é”®ï¼šæ˜Ÿæ˜Ÿåå‘æ—‹è½¬ï¼Œå§‹ç»ˆæ­£å¯¹é•œå¤´
                } else {
                    particles.rotation.y += rotationSpeed;
                    if(currentState === 'sphere') particles.rotation.x += rotationSpeed / 2;
                }
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
