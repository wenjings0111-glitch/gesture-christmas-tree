<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Starry Night Gesture Control - Pixel Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #d4af37; border-radius: 10px;
            overflow: hidden; transform: scaleX(-1); z-index: 100;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 40px; left: 40px; color: #d4af37;
            pointer-events: none; z-index: 100;
        }
        .label { font-size: 10px; letter-spacing: 4px; opacity: 0.6; text-transform: uppercase; }
        h1 { margin: 10px 0; font-weight: 200; font-size: 28px; letter-spacing: 2px; }
        #status { font-style: italic; color: #fff; text-shadow: 0 0 10px #d4af37; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="label">Interactive Art Experience</div>
        <h1>STARRY NIGHT: PIXEL PARTICLES</h1>
        <div id="status">正在加载《星夜》像素数据...</div>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 15000; // 粒子数量
        let currentState = 'painting'; // 'painting', 'gather', 'scatter'
        
        // 预设坐标数组
        let posPainting, posGather, posScatter;
        let colors;

        async function init() {
            // 1. 初始化场景
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // 2. 加载图片并提取像素
            await loadPixelData("https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/600px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg");

            // 3. 设置手势识别
            initHands();
            
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        async function loadPixelData(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200; // 采样宽度
                    canvas.height = 150; // 采样高度
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    posPainting = new Float32Array(PARTICLE_COUNT * 3);
                    posGather = new Float32Array(PARTICLE_COUNT * 3);
                    posScatter = new Float32Array(PARTICLE_COUNT * 3);
                    colors = new Float32Array(PARTICLE_COUNT * 3);

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        
                        // 随机采样图片中的像素点
                        const x = Math.floor(Math.random() * canvas.width);
                        const y = Math.floor(Math.random() * canvas.height);
                        const pixelIndex = (y * canvas.width + x) * 4;

                        // 状态1: 名画形态 (Painting)
                        posPainting[i3] = (x - canvas.width / 2) * 2.5;
                        posPainting[i3 + 1] = -(y - canvas.height / 2) * 2.5;
                        posPainting[i3 + 2] = 0;

                        // 状态2: 圣诞树/圆锥形态 (Gather)
                        const h = Math.random() * 300;
                        const r = (300 - h) * 0.3;
                        const angle = Math.random() * Math.PI * 2;
                        posGather[i3] = Math.cos(angle) * r;
                        posGather[i3 + 1] = h - 150;
                        posGather[i3 + 2] = Math.sin(angle) * r;

                        // 状态3: 散开态 (Scatter)
                        posScatter[i3] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 1] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 2] = (Math.random() - 0.5) * 1000;

                        // 颜色：混合图片颜色与金色
                        const r_col = imgData[pixelIndex] / 255;
                        const g_col = imgData[pixelIndex + 1] / 255;
                        const b_col = imgData[pixelIndex + 2] / 255;
                        
                        // 加入金银色调
                        colors[i3] = r_col * 0.8 + 0.2; // 偏红/金
                        colors[i3 + 1] = g_col * 0.7 + 0.15;
                        colors[i3 + 2] = b_col * 0.5;
                    }

                    createParticleSystem();
                    document.getElementById('status').innerText = "加载完成。张开手掌散开，握拳聚合。";
                    resolve();
                };
            });
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            // 初始设为名画形态
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posPainting), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function transformTo(type) {
            if (currentState === type) return;
            currentState = type;
            
            const targetPos = type === 'gather' ? posGather : (type === 'scatter' ? posScatter : posPainting);
            const posAttr = geometry.attributes.position;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                gsap.to(posAttr.array, {
                    [i3]: targetPos[i3],
                    [i3+1]: targetPos[i3+1],
                    [i3+2]: targetPos[i3+2],
                    duration: 1.5,
                    ease: "power2.inOut",
                    delay: Math.random() * 0.3,
                    onUpdate: () => posAttr.needsUpdate = true
                });
            }
        }

        function initHands() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 手势检测：握拳 vs 张开
                const fingerTips = [8, 12, 16, 20];
                const wrist = landmarks[0];
                let totalDist = 0;
                fingerTips.forEach(idx => {
                    const tip = landmarks[idx];
                    totalDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                });

                if (totalDist < 0.6) {
                    transformTo('gather');
                } else {
                    transformTo('scatter');
                }

                // 2. 相机控制：手部位置映射
                const midX = landmarks[9].x - 0.5;
                const midY = landmarks[9].y - 0.5;
                gsap.to(camera.position, {
                    x: midX * 800,
                    y: -midY * 800,
                    duration: 0.8
                });
                camera.lookAt(0, 0, 0);
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                particles.rotation.y += 0.002;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
