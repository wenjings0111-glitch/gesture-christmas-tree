<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Starry Night Gesture Control - Pixel Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #d4af37; border-radius: 10px;
            overflow: hidden; transform: scaleX(-1); z-index: 100;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 40px; left: 40px; color: #d4af37;
            pointer-events: none; z-index: 100;
        }
        .label { font-size: 10px; letter-spacing: 4px; opacity: 0.6; text-transform: uppercase; }
        h1 { margin: 10px 0; font-weight: 200; font-size: 28px; letter-spacing: 2px; }
        #status { font-style: italic; color: #fff; text-shadow: 0 0 10px #d4af37; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="label">Interactive Art Experience</div>
        <h1>STARRY NIGHT: PIXEL PARTICLES</h1>
        <div id="status">正在加载《星夜》像素数据...</div>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 15000; // 粒子数量
        let currentState = 'painting'; // 'painting', 'gather', 'scatter', 'sphere'
        
        // 预设坐标数组
        let posPainting, posGather, posScatter, posSphere;
        let baseColors, goldColors, silverColors;

        async function init() {
            // 1. 初始化场景
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // 2. 加载图片并提取像素
            await loadPixelData("https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/600px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg");

            // 3. 设置手势识别
            initHands();
            
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        async function loadPixelData(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200; // 采样宽度
                    canvas.height = 150; // 采样高度
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    posPainting = new Float32Array(PARTICLE_COUNT * 3);
                    posGather = new Float32Array(PARTICLE_COUNT * 3);
                    posScatter = new Float32Array(PARTICLE_COUNT * 3);
                    posSphere = new Float32Array(PARTICLE_COUNT * 3);
                    
                    baseColors = new Float32Array(PARTICLE_COUNT * 3);
                    goldColors = new Float32Array(PARTICLE_COUNT * 3);
                    silverColors = new Float32Array(PARTICLE_COUNT * 3);

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        
                        const x = Math.floor(Math.random() * canvas.width);
                        const y = Math.floor(Math.random() * canvas.height);
                        const pixelIndex = (y * canvas.width + x) * 4;

                        // 状态1: 名画形态 (Painting)
                        posPainting[i3] = (x - canvas.width / 2) * 2.5;
                        posPainting[i3 + 1] = -(y - canvas.height / 2) * 2.5;
                        posPainting[i3 + 2] = 0;

                        // 状态2: 金色圣诞树形态 (Gather)
                        const h = Math.random() * 300;
                        const rTree = (300 - h) * 0.3;
                        const angleTree = Math.random() * Math.PI * 2;
                        posGather[i3] = Math.cos(angleTree) * rTree;
                        posGather[i3 + 1] = h - 150;
                        posGather[i3 + 2] = Math.sin(angleTree) * rTree;

                        // 新增状态: 银色圆球形态 (Sphere)
                        const radius = 150;
                        const u = Math.random();
                        const v = Math.random();
                        const thetaSphere = 2 * Math.PI * u;
                        const phiSphere = Math.acos(2 * v - 1);
                        posSphere[i3] = radius * Math.sin(phiSphere) * Math.cos(thetaSphere);
                        posSphere[i3+1] = radius * Math.sin(phiSphere) * Math.sin(thetaSphere);
                        posSphere[i3+2] = radius * Math.cos(phiSphere);

                        // 状态3: 散开态 (Scatter)
                        posScatter[i3] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 1] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 2] = (Math.random() - 0.5) * 1000;

                        // 基础像素颜色
                        const r_col = imgData[pixelIndex] / 255;
                        const g_col = imgData[pixelIndex + 1] / 255;
                        const b_col = imgData[pixelIndex + 2] / 255;
                        baseColors[i3] = r_col; baseColors[i3+1] = g_col; baseColors[i3+2] = b_col;

                        // 金属金色调
                        goldColors[i3] = r_col * 0.8 + 0.2; 
                        goldColors[i3 + 1] = g_col * 0.7 + 0.15;
                        goldColors[i3 + 2] = b_col * 0.5;

                        // 金属银色调
                        silverColors[i3] = r_col * 0.4 + 0.5;
                        silverColors[i3 + 1] = g_col * 0.4 + 0.5;
                        silverColors[i3 + 2] = b_col * 0.4 + 0.6;
                    }

                    createParticleSystem();
                    document.getElementById('status').innerText = "加载完成。张开手掌散开，握拳聚合。";
                    resolve();
                };
            });
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posPainting), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(baseColors), 3));

            const material = new THREE.PointsMaterial({
                size: 2.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function transformTo(type) {
            // 如果是握拳(gather)，则随机选择 'gather'(树) 或 'sphere'(球)
            let finalType = type;
            if (type === 'gather') {
                if (currentState === 'gather' || currentState === 'sphere') return;
                finalType = Math.random() > 0.5 ? 'gather' : 'sphere';
            } else if (currentState === type) {
                return;
            }

            currentState = finalType;
            
            let targetPos, targetColor, statusText;
            if (finalType === 'gather') {
                targetPos = posGather;
                targetColor = goldColors;
                statusText = "模式: 金色圣诞树";
            } else if (finalType === 'sphere') {
                targetPos = posSphere;
                targetColor = silverColors;
                statusText = "模式: 银色行球";
            } else if (finalType === 'scatter') {
                targetPos = posScatter;
                targetColor = baseColors;
                statusText = "模式: 散开态";
            } else {
                targetPos = posPainting;
                targetColor = baseColors;
                statusText = "模式: 名画形态";
            }

            document.getElementById('status').innerText = statusText;
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 位置过渡
                gsap.to(posAttr.array, {
                    [i3]: targetPos[i3],
                    [i3+1]: targetPos[i3+1],
                    [i3+2]: targetPos[i3+2],
                    duration: 1.5,
                    ease: "power2.inOut",
                    delay: Math.random() * 0.3,
                    onUpdate: () => posAttr.needsUpdate = true
                });
                // 颜色过渡
                gsap.to(colAttr.array, {
                    [i3]: targetColor[i3],
                    [i3+1]: targetColor[i3+1],
                    [i3+2]: targetColor[i3+2],
                    duration: 1.5,
                    onUpdate: () => colAttr.needsUpdate = true
                });
            }
        }

        function initHands() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 手势检测：握拳判定
                const fingerTips = [8, 12, 16, 20];
                const wrist = landmarks[0];
                let totalDist = 0;
                fingerTips.forEach(idx => {
                    const tip = landmarks[idx];
                    totalDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                });

                if (totalDist < 0.6) {
                    transformTo('gather'); // 这里会进入随机树/球逻辑
                } else {
                    transformTo('scatter');
                }

                // 2. 相机控制
                const midX = landmarks[9].x - 0.5;
                const midY = landmarks[9].y - 0.5;
                gsap.to(camera.position, {
                    x: midX * 800,
                    y: -midY * 800,
                    duration: 0.8
                });
                camera.lookAt(0, 0, 0);
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                // 持续旋转增加动感
                particles.rotation.y += 0.002;
                if(currentState === 'sphere') {
                    particles.rotation.x += 0.001; // 球体形态额外旋转
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
