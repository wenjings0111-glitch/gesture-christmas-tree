<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Starry Night Gesture Control - Galaxy Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* è§†é¢‘å®¹å™¨æ·»åŠ è¿‡æ¸¡åŠ¨ç”» */
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid #d4af37; border-radius: 10px;
            overflow: hidden; transform: scaleX(-1); z-index: 100;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui {
            position: absolute; top: 40px; left: 40px; color: #d4af37;
            pointer-events: none; z-index: 100;
        }
        .label { font-size: 10px; letter-spacing: 4px; opacity: 0.6; text-transform: uppercase; }
        h1 { margin: 10px 0; font-weight: 200; font-size: 28px; letter-spacing: 2px; }
        #status { font-style: italic; color: #fff; text-shadow: 0 0 10px #d4af37; }

        /* --- æ–°å¢ï¼šå…¨èƒ½æ§åˆ¶é¢æ¿æ ·å¼ --- */
        #control-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 12px;
            padding: 15px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            color: #d4af37;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
        .panel-item { display: flex; align-items: center; gap: 10px; font-size: 14px; }
        input[type="range"] { accent-color: #d4af37; cursor: pointer; }
        .panel-btns { display: flex; gap: 8px; }
        button {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        button:hover { background: rgba(212, 175, 55, 0.4); }
    </style>
</head>
<body>

    <div id="control-panel">
        <div class="panel-item">
            <label>ç²’å­é€Ÿåº¦</label>
            <input type="range" id="speed-slider" min="0" max="0.02" step="0.001" value="0.002">
        </div>
        <div class="panel-btns">
            <button onclick="toggleFullscreen()">å…¨å±å±•ç¤º</button>
            <button onclick="togglePreview()">ğŸ“· é¢„è§ˆæ˜¾ç¤º/éšè—</button>
        </div>
    </div>

    <div id="ui">
        <div class="label">Interactive Art Experience</div>
        <h1>STARRY NIGHT: PIXEL PARTICLES</h1>
        <div id="status">æ­£åœ¨åŠ è½½ã€Šæ˜Ÿå¤œã€‹åƒç´ æ•°æ®...</div>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 15000;
        let currentState = 'painting'; 
        
        // --- æ–°å¢ï¼šæ§åˆ¶å˜é‡ ---
        let rotationSpeed = 0.002;
        let isPreviewVisible = true;

        let posPainting, posGather, posScatter, posSphere;
        let baseColors, goldColors, silverColors;

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 400;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            await loadPixelData("https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/600px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg");

            initHands();
            
            // ç›‘å¬é€Ÿåº¦æ»‘å—
            document.getElementById('speed-slider').oninput = (e) => {
                rotationSpeed = parseFloat(e.target.value);
            };

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        // --- æ–°å¢ï¼šæ§åˆ¶é¢æ¿åŠŸèƒ½å‡½æ•° ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }

        function togglePreview() {
            isPreviewVisible = !isPreviewVisible;
            const container = document.getElementById('video-container');
            container.style.opacity = isPreviewVisible ? "1" : "0";
            container.style.pointerEvents = isPreviewVisible ? "auto" : "none";
        }

        async function loadPixelData(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200; 
                    canvas.height = 150; 
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    posPainting = new Float32Array(PARTICLE_COUNT * 3);
                    posGather = new Float32Array(PARTICLE_COUNT * 3);
                    posScatter = new Float32Array(PARTICLE_COUNT * 3);
                    posSphere = new Float32Array(PARTICLE_COUNT * 3);
                    
                    baseColors = new Float32Array(PARTICLE_COUNT * 3);
                    goldColors = new Float32Array(PARTICLE_COUNT * 3);
                    silverColors = new Float32Array(PARTICLE_COUNT * 3);

                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const i3 = i * 3;
                        const x = Math.floor(Math.random() * canvas.width);
                        const y = Math.floor(Math.random() * canvas.height);
                        const pixelIndex = (y * canvas.width + x) * 4;

                        posPainting[i3] = (x - canvas.width / 2) * 2.5;
                        posPainting[i3 + 1] = -(y - canvas.height / 2) * 2.5;
                        posPainting[i3 + 2] = 0;

                        const h = Math.random() * 300;
                        const rTree = (300 - h) * 0.3;
                        const angleTree = Math.random() * Math.PI * 2;
                        posGather[i3] = Math.cos(angleTree) * rTree;
                        posGather[i3 + 1] = h - 150;
                        posGather[i3 + 2] = Math.sin(angleTree) * rTree;

                        const radius = 150;
                        const u = Math.random();
                        const v = Math.random();
                        const thetaSphere = 2 * Math.PI * u;
                        const phiSphere = Math.acos(2 * v - 1);
                        posSphere[i3] = radius * Math.sin(phiSphere) * Math.cos(thetaSphere);
                        posSphere[i3+1] = radius * Math.sin(phiSphere) * Math.sin(thetaSphere);
                        posSphere[i3+2] = radius * Math.cos(phiSphere);

                        posScatter[i3] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 1] = (Math.random() - 0.5) * 1000;
                        posScatter[i3 + 2] = (Math.random() - 0.5) * 1000;

                        const r_col = imgData[pixelIndex] / 255;
                        const g_col = imgData[pixelIndex + 1] / 255;
                        const b_col = imgData[pixelIndex + 2] / 255;
                        baseColors[i3] = r_col; baseColors[i3+1] = g_col; baseColors[i3+2] = b_col;

                        goldColors[i3] = r_col * 0.8 + 0.2; 
                        goldColors[i3 + 1] = g_col * 0.7 + 0.15;
                        goldColors[i3 + 2] = b_col * 0.5;

                        silverColors[i3] = r_col * 0.4 + 0.5;
                        silverColors[i3 + 1] = g_col * 0.4 + 0.5;
                        silverColors[i3 + 2] = b_col * 0.4 + 0.6;
                    }

                    createParticleSystem();
                    document.getElementById('status').innerText = "åŠ è½½å®Œæˆã€‚å¼ å¼€æ‰‹æŒæ•£å¼€ï¼Œæ¡æ‹³èšåˆã€‚";
                    resolve();
                };
            });
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(posPainting), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(baseColors), 3));

            const material = new THREE.PointsMaterial({
                size: 2.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function transformTo(type) {
            let finalType = type;
            if (type === 'gather') {
                if (currentState === 'gather' || currentState === 'sphere') return;
                finalType = Math.random() > 0.5 ? 'gather' : 'sphere';
            } else if (currentState === type) {
                return;
            }

            currentState = finalType;
            
            let targetPos, targetColor, statusText;
            if (finalType === 'gather') {
                targetPos = posGather; targetColor = goldColors; statusText = "æ¨¡å¼: é‡‘è‰²åœ£è¯æ ‘";
            } else if (finalType === 'sphere') {
                targetPos = posSphere; targetColor = silverColors; statusText = "æ¨¡å¼: é“¶è‰²è¡Œçƒ";
            } else if (finalType === 'scatter') {
                targetPos = posScatter; targetColor = baseColors; statusText = "æ¨¡å¼: æ•£å¼€æ€";
            } else {
                targetPos = posPainting; targetColor = baseColors; statusText = "æ¨¡å¼: åç”»å½¢æ€";
            }

            document.getElementById('status').innerText = statusText;
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                gsap.to(posAttr.array, {
                    [i3]: targetPos[i3], [i3+1]: targetPos[i3+1], [i3+2]: targetPos[i3+2],
                    duration: 1.5, ease: "power2.inOut", delay: Math.random() * 0.3,
                    onUpdate: () => posAttr.needsUpdate = true
                });
                gsap.to(colAttr.array, {
                    [i3]: targetColor[i3], [i3+1]: targetColor[i3+1], [i3+2]: targetColor[i3+2],
                    duration: 1.5, onUpdate: () => colAttr.needsUpdate = true
                });
            }
        }

        function initHands() {
            const videoElement = document.getElementById('input_video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
                const landmarks = results.multiHandLandmarks[0];
                const fingerTips = [8, 12, 16, 20];
                const wrist = landmarks[0];
                let totalDist = 0;
                fingerTips.forEach(idx => {
                    const tip = landmarks[idx];
                    totalDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                });

                if (totalDist < 0.6) {
                    transformTo('gather');
                } else {
                    transformTo('scatter');
                }

                const midX = landmarks[9].x - 0.5;
                const midY = landmarks[9].y - 0.5;
                gsap.to(camera.position, {
                    x: midX * 800,
                    y: -midY * 800,
                    duration: 0.8
                });
                camera.lookAt(0, 0, 0);
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                // ä½¿ç”¨æ§åˆ¶å˜é‡æ§åˆ¶é€Ÿåº¦
                particles.rotation.y += rotationSpeed;
                if(currentState === 'sphere') {
                    particles.rotation.x += rotationSpeed / 2;
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
