<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Starry Night - Gesture Control 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* 视频反馈窗口 */
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); /* 镜像显示 */
            z-index: 10;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }

        /* UI 提示 */
        #ui-overlay {
            position: absolute; top: 30px; left: 30px;
            color: #ffd700; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            pointer-events: none;
        }
        .status-tag { font-size: 12px; letter-spacing: 2px; text-transform: uppercase; color: #fff; opacity: 0.7; }
        h1 { margin: 5px 0; font-weight: 300; font-size: 24px; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div class="status-tag">Interactive Particle System</div>
        <h1>STARRY NIGHT · GOLDEN EDITION</h1>
        <p id="gesture-hint">正在初始化摄像头...</p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.150.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        /**
         * 1. 核心场景配置
         */
        let scene, camera, renderer, composer, particles;
        const PARTICLE_COUNT = 15000;
        let currentState = 'scatter'; // 'gather', 'scatter'
        
        const COLORS = {
            gold: new THREE.Color(0xD4AF37),
            silver: new THREE.Color(0xC0C0C0),
            dark: new THREE.Color(0x050505)
        };

        const initScene = () => {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050505, 1);
            document.getElementById('container').appendChild(renderer.domElement);

            // 后期处理：辉光
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.2;
            bloomPass.strength = 2.0;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticles();
            window.addEventListener('resize', onWindowResize);
        };

        /**
         * 2. 粒子创建与几何变换逻辑
         */
        const createParticles = () => {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            // 存储不同形态的目标坐标
            const gatherPositions = new Float32Array(PARTICLE_COUNT * 3);
            const scatterPositions = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 初始散开态 (球状分布)
                const r = 200 * Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                scatterPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                scatterPositions[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                scatterPositions[i3+2] = r * Math.cos(phi);

                // 初始聚合态 (圆锥体/圣诞树)
                const height = 150 * Math.random();
                const radiusAtHeight = (150 - height) * 0.4;
                const angle = Math.random() * Math.PI * 2;
                gatherPositions[i3] = Math.cos(angle) * radiusAtHeight;
                gatherPositions[i3+1] = height - 75;
                gatherPositions[i3+2] = Math.sin(angle) * radiusAtHeight;

                // 初始位置
                positions[i3] = scatterPositions[i3];
                positions[i3+1] = scatterPositions[i3+1];
                positions[i3+2] = scatterPositions[i3+2];

                // 颜色混搭 (金+银)
                const mixColor = Math.random() > 0.5 ? COLORS.gold : COLORS.silver;
                colors[i3] = mixColor.r;
                colors[i3+1] = mixColor.g;
                colors[i3+2] = mixColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.userData = { gatherPositions, scatterPositions };

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        };

        // 状态切换动画
        const transitionTo = (state) => {
            if (currentState === state) return;
            currentState = state;
            const posAttr = particles.geometry.attributes.position;
            const targetData = state === 'gather' ? 
                               particles.geometry.userData.gatherPositions : 
                               particles.geometry.userData.scatterPositions;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                gsap.to(posAttr.array, {
                    [i3]: targetData[i3],
                    [i3+1]: targetData[i3+1],
                    [i3+2]: targetData[i3+2],
                    duration: 2,
                    ease: "expo.out",
                    delay: Math.random() * 0.5,
                    onUpdate: () => posAttr.needsUpdate = true
                });
            }
        };

        /**
         * 3. MediaPipe 手势识别逻辑
         */
        const videoElement = document.getElementById('input_video');
        const hint = document.getElementById('gesture-hint');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // 判断握拳还是张开 (计算指尖与手掌中心距离)
                const palmCenter = hand[0];
                const indexTip = hand[8];
                const distance = Math.hypot(indexTip.x - palmCenter.x, indexTip.y - palmCenter.y);

                if (distance < 0.15) {
                    hint.innerText = "状态：握拳 - 聚合形态";
                    transitionTo('gather');
                } else {
                    hint.innerText = "状态：张开 - 散开星空";
                    transitionTo('scatter');
                }

                // 手部移动控制相机旋转 (上下左右)
                const targetX = (hand[9].x - 0.5) * 400;
                const targetY = -(hand[9].y - 0.5) * 400;
                gsap.to(camera.position, {
                    x: targetX,
                    y: targetY,
                    duration: 1,
                    ease: "power2.out"
                });
                camera.lookAt(0, 0, 0);
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraPipe = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraPipe.start();

        /**
         * 4. 渲染循环
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        const animate = () => {
            requestAnimationFrame(animate);
            
            // 粒子微动（呼吸感）
            if (particles) {
                particles.rotation.y += 0.001;
                particles.rotation.z += 0.0005;
            }

            composer.render();
        };

        initScene();
        animate();

    </script>
</body>
</html>
